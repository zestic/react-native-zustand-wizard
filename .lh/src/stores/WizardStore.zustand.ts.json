{
    "sourceFile": "src/stores/WizardStore.zustand.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1752380104034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752380120111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,8 +43,9 @@\n   getStepData: (stepId: string) => StepData;\n   getWizardData: () => Record<string, StepData>;\n   getNextStep: () => Step | undefined;\n   getPreviousStep: () => Step | undefined;\n+  // These will be computed properties that update with state\n   canMoveNext: boolean;\n   isFirstStep: boolean;\n   isLastStep: boolean;\n   nextButtonLabel: string;\n"
                },
                {
                    "date": 1752380141141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,21 +71,47 @@\n     }\n   }\n };\n \n+// Helper function to compute derived state\n+const computeDerivedState = (state: WizardState) => {\n+  const currentStep = state.steps.find((s) => s.order === state.currentStepPosition);\n+  return {\n+    canMoveNext: currentStep ? currentStep.canMoveNext : false,\n+    isFirstStep: state.currentStepPosition === 1,\n+    isLastStep: state.currentStepPosition === state.totalSteps,\n+    nextButtonLabel: currentStep?.nextLabel || 'Next',\n+    previousButtonLabel: currentStep?.previousLabel || 'Previous',\n+  };\n+};\n+\n // Create the Zustand store\n export const useWizardStore = create<WizardStore>()(\n   devtools(\n-    (set, get) => ({\n-      // Initial state\n-      currentStepId: '',\n-      currentStepPosition: 0,\n-      isLoading: false,\n-      error: '',\n-      stepData: new Map<string, StepData>(),\n-      steps: [],\n-      totalSteps: 0,\n+    (set, get) => {\n+      const updateStateWithDerived = (newState: Partial<WizardState>) => {\n+        const currentState = get();\n+        const updatedState = { ...currentState, ...newState };\n+        const derived = computeDerivedState(updatedState);\n+        return { ...updatedState, ...derived };\n+      };\n \n+      return {\n+        // Initial state\n+        currentStepId: '',\n+        currentStepPosition: 0,\n+        isLoading: false,\n+        error: '',\n+        stepData: new Map<string, StepData>(),\n+        steps: [],\n+        totalSteps: 0,\n+        // Initial derived state\n+        canMoveNext: false,\n+        isFirstStep: false,\n+        isLastStep: false,\n+        nextButtonLabel: 'Next',\n+        previousButtonLabel: 'Previous',\n+\n       // Actions\n       setLoading: (isLoading: boolean) => {\n         set({ isLoading }, false, 'setLoading');\n       },\n"
                },
                {
                    "date": 1752380162451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,33 +110,33 @@\n         isLastStep: false,\n         nextButtonLabel: 'Next',\n         previousButtonLabel: 'Previous',\n \n-      // Actions\n-      setLoading: (isLoading: boolean) => {\n-        set({ isLoading }, false, 'setLoading');\n-      },\n+        // Actions\n+        setLoading: (isLoading: boolean) => {\n+          set(updateStateWithDerived({ isLoading }), false, 'setLoading');\n+        },\n \n-      setError: (error: string | null) => {\n-        set({ error: error || '' }, false, 'setError');\n-      },\n+        setError: (error: string | null) => {\n+          set(updateStateWithDerived({ error: error || '' }), false, 'setError');\n+        },\n \n-      setCurrentStep: async (stepId: string) => {\n-        const state = get();\n-        const step = state.steps.find((s) => s.id === stepId);\n-        if (!step) {\n-          console.error(`Step with id ${stepId} not found`);\n-          return;\n-        }\n-        set(\n-          {\n-            currentStepId: stepId,\n-            currentStepPosition: step.order,\n-          },\n-          false,\n-          'setCurrentStep'\n-        );\n-      },\n+        setCurrentStep: async (stepId: string) => {\n+          const state = get();\n+          const step = state.steps.find((s) => s.id === stepId);\n+          if (!step) {\n+            console.error(`Step with id ${stepId} not found`);\n+            return;\n+          }\n+          set(\n+            updateStateWithDerived({\n+              currentStepId: stepId,\n+              currentStepPosition: step.order,\n+            }),\n+            false,\n+            'setCurrentStep'\n+          );\n+        },\n \n       moveNext: async () => {\n         const state = get();\n         const nextStep = state.getNextStep();\n"
                },
                {
                    "date": 1752380176942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -136,37 +136,37 @@\n             'setCurrentStep'\n           );\n         },\n \n-      moveNext: async () => {\n-        const state = get();\n-        const nextStep = state.getNextStep();\n-        if (nextStep) {\n-          set(\n-            {\n-              currentStepId: nextStep.id,\n-              currentStepPosition: nextStep.order,\n-            },\n-            false,\n-            'moveNext'\n-          );\n-        }\n-      },\n+        moveNext: async () => {\n+          const state = get();\n+          const nextStep = state.getNextStep();\n+          if (nextStep) {\n+            set(\n+              updateStateWithDerived({\n+                currentStepId: nextStep.id,\n+                currentStepPosition: nextStep.order,\n+              }),\n+              false,\n+              'moveNext'\n+            );\n+          }\n+        },\n \n-      moveBack: async () => {\n-        const state = get();\n-        const previousStep = state.getPreviousStep();\n-        if (previousStep) {\n-          set(\n-            {\n-              currentStepId: previousStep.id,\n-              currentStepPosition: previousStep.order,\n-            },\n-            false,\n-            'moveBack'\n-          );\n-        }\n-      },\n+        moveBack: async () => {\n+          const state = get();\n+          const previousStep = state.getPreviousStep();\n+          if (previousStep) {\n+            set(\n+              updateStateWithDerived({\n+                currentStepId: previousStep.id,\n+                currentStepPosition: previousStep.order,\n+              }),\n+              false,\n+              'moveBack'\n+            );\n+          }\n+        },\n \n       setStepData: async (stepId: string, data: StepData) => {\n         const state = get();\n         const step = state.steps.find((s) => s.id === stepId);\n"
                },
                {
                    "date": 1752380193417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,28 +166,28 @@\n             );\n           }\n         },\n \n-      setStepData: async (stepId: string, data: StepData) => {\n-        const state = get();\n-        const step = state.steps.find((s) => s.id === stepId);\n-        if (!step) {\n-          console.error(`Step with id ${stepId} not found`);\n-          return;\n-        }\n-        const newStepData = new Map(state.stepData);\n-        newStepData.set(stepId, data);\n-        set({ stepData: newStepData }, false, 'setStepData');\n-      },\n+        setStepData: async (stepId: string, data: StepData) => {\n+          const state = get();\n+          const step = state.steps.find((s) => s.id === stepId);\n+          if (!step) {\n+            console.error(`Step with id ${stepId} not found`);\n+            return;\n+          }\n+          const newStepData = new Map(state.stepData);\n+          newStepData.set(stepId, data);\n+          set(updateStateWithDerived({ stepData: newStepData }), false, 'setStepData');\n+        },\n \n-      updateField: async (stepId: string, field: string, value: unknown) => {\n-        const state = get();\n-        const existingData = state.stepData.get(stepId) || {};\n-        const newData = { ...existingData, [field]: value };\n-        const newStepData = new Map(state.stepData);\n-        newStepData.set(stepId, newData);\n-        set({ stepData: newStepData }, false, 'updateField');\n-      },\n+        updateField: async (stepId: string, field: string, value: unknown) => {\n+          const state = get();\n+          const existingData = state.stepData.get(stepId) || {};\n+          const newData = { ...existingData, [field]: value };\n+          const newStepData = new Map(state.stepData);\n+          newStepData.set(stepId, newData);\n+          set(updateStateWithDerived({ stepData: newStepData }), false, 'updateField');\n+        },\n \n       reset: async () => {\n         const state = get();\n         const firstStep = [...state.steps]\n"
                },
                {
                    "date": 1752380208475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,40 +187,40 @@\n           newStepData.set(stepId, newData);\n           set(updateStateWithDerived({ stepData: newStepData }), false, 'updateField');\n         },\n \n-      reset: async () => {\n-        const state = get();\n-        const firstStep = [...state.steps]\n-          .sort((a, b) => a.order - b.order)[0];\n-        \n-        if (firstStep) {\n-          set(\n-            {\n-              currentStepId: firstStep.id,\n-              currentStepPosition: firstStep.order,\n-              stepData: new Map<string, StepData>(),\n-              isLoading: false,\n-              error: '',\n-            },\n-            false,\n-            'reset'\n-          );\n-        } else {\n-          set(\n-            {\n-              currentStepId: '',\n-              currentStepPosition: 0,\n-              stepData: new Map<string, StepData>(),\n-              isLoading: false,\n-              error: '',\n-            },\n-            false,\n-            'reset'\n-          );\n-        }\n-      },\n+        reset: async () => {\n+          const state = get();\n+          const firstStep = [...state.steps]\n+            .sort((a, b) => a.order - b.order)[0];\n \n+          if (firstStep) {\n+            set(\n+              updateStateWithDerived({\n+                currentStepId: firstStep.id,\n+                currentStepPosition: firstStep.order,\n+                stepData: new Map<string, StepData>(),\n+                isLoading: false,\n+                error: '',\n+              }),\n+              false,\n+              'reset'\n+            );\n+          } else {\n+            set(\n+              updateStateWithDerived({\n+                currentStepId: '',\n+                currentStepPosition: 0,\n+                stepData: new Map<string, StepData>(),\n+                isLoading: false,\n+                error: '',\n+              }),\n+              false,\n+              'reset'\n+            );\n+          }\n+        },\n+\n       initializeSteps: (\n         steps: Omit<Step, 'nextLabel' | 'previousLabel'>[],\n         defaultNextLabel = 'Next',\n         defaultPreviousLabel = 'Previous',\n"
                },
                {
                    "date": 1752380230680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -219,42 +219,42 @@\n             );\n           }\n         },\n \n-      initializeSteps: (\n-        steps: Omit<Step, 'nextLabel' | 'previousLabel'>[],\n-        defaultNextLabel = 'Next',\n-        defaultPreviousLabel = 'Previous',\n-        finishLabel = 'Finish'\n-      ) => {\n-        const lastStepOrder = Math.max(...steps.map((s) => s.order), 0);\n-        \n-        const processedSteps: Step[] = steps.map((step) => {\n-          const isLast = step.order === lastStepOrder;\n-          return {\n-            ...step,\n-            nextLabel: isLast ? finishLabel : defaultNextLabel,\n-            previousLabel: defaultPreviousLabel,\n-          };\n-        });\n+        initializeSteps: (\n+          steps: Omit<Step, 'nextLabel' | 'previousLabel'>[],\n+          defaultNextLabel = 'Next',\n+          defaultPreviousLabel = 'Previous',\n+          finishLabel = 'Finish'\n+        ) => {\n+          const lastStepOrder = Math.max(...steps.map((s) => s.order), 0);\n \n-        validateSteps(processedSteps);\n+          const processedSteps: Step[] = steps.map((step) => {\n+            const isLast = step.order === lastStepOrder;\n+            return {\n+              ...step,\n+              nextLabel: isLast ? finishLabel : defaultNextLabel,\n+              previousLabel: defaultPreviousLabel,\n+            };\n+          });\n \n-        const sortedSteps = [...processedSteps].sort((a, b) => a.order - b.order);\n-        const firstStep = sortedSteps[0];\n+          validateSteps(processedSteps);\n \n-        set(\n-          {\n-            steps: processedSteps,\n-            totalSteps: processedSteps.length,\n-            currentStepId: firstStep?.id || '',\n-            currentStepPosition: firstStep?.order || 0,\n-          },\n-          false,\n-          'initializeSteps'\n-        );\n-      },\n+          const sortedSteps = [...processedSteps].sort((a, b) => a.order - b.order);\n+          const firstStep = sortedSteps[0];\n \n+          set(\n+            updateStateWithDerived({\n+              steps: processedSteps,\n+              totalSteps: processedSteps.length,\n+              currentStepId: firstStep?.id || '',\n+              currentStepPosition: firstStep?.order || 0,\n+            }),\n+            false,\n+            'initializeSteps'\n+          );\n+        },\n+\n       // Selectors (computed values)\n       getCurrentStep: () => {\n         const state = get();\n         return state.steps.find((s) => s.order === state.currentStepPosition);\n"
                },
                {
                    "date": 1752380254195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,82 +253,55 @@\n             'initializeSteps'\n           );\n         },\n \n-      // Selectors (computed values)\n-      getCurrentStep: () => {\n-        const state = get();\n-        return state.steps.find((s) => s.order === state.currentStepPosition);\n-      },\n+        // Selectors (computed values)\n+        getCurrentStep: () => {\n+          const state = get();\n+          return state.steps.find((s) => s.order === state.currentStepPosition);\n+        },\n \n-      getStepById: (id: string) => {\n-        const state = get();\n-        return state.steps.find((s) => s.id === id);\n-      },\n+        getStepById: (id: string) => {\n+          const state = get();\n+          return state.steps.find((s) => s.id === id);\n+        },\n \n-      getStepData: (stepId: string) => {\n-        const state = get();\n-        return state.stepData.get(stepId) || {};\n-      },\n+        getStepData: (stepId: string) => {\n+          const state = get();\n+          return state.stepData.get(stepId) || {};\n+        },\n \n-      getWizardData: () => {\n-        const state = get();\n-        const wizardData: Record<string, StepData> = {};\n-        state.steps.forEach((step) => {\n-          const stepData = state.stepData.get(step.id);\n-          if (stepData) {\n-            wizardData[step.id] = stepData;\n-          }\n-        });\n-        return wizardData;\n-      },\n+        getWizardData: () => {\n+          const state = get();\n+          const wizardData: Record<string, StepData> = {};\n+          state.steps.forEach((step) => {\n+            const stepData = state.stepData.get(step.id);\n+            if (stepData) {\n+              wizardData[step.id] = stepData;\n+            }\n+          });\n+          return wizardData;\n+        },\n \n-      getNextStep: () => {\n-        const state = get();\n-        const currentStep = state.getCurrentStep();\n-        if (!currentStep) return undefined;\n-        return state.steps\n-          .filter((s) => s.order > currentStep.order)\n-          .sort((a, b) => a.order - b.order)[0];\n-      },\n+        getNextStep: () => {\n+          const state = get();\n+          const currentStep = state.getCurrentStep();\n+          if (!currentStep) return undefined;\n+          return state.steps\n+            .filter((s) => s.order > currentStep.order)\n+            .sort((a, b) => a.order - b.order)[0];\n+        },\n \n-      getPreviousStep: () => {\n-        const state = get();\n-        const currentStep = state.getCurrentStep();\n-        if (!currentStep) return undefined;\n-        return state.steps\n-          .filter((s) => s.order < currentStep.order)\n-          .sort((a, b) => b.order - a.order)[0];\n-      },\n-\n-      // Computed properties as functions (Zustand doesn't support getters the same way)\n-      canMoveNext: (() => {\n-        const state = get();\n-        const currentStep = state.getCurrentStep();\n-        return currentStep ? currentStep.canMoveNext : false;\n-      })(),\n-\n-      isFirstStep: (() => {\n-        const state = get();\n-        return state.currentStepPosition === 1;\n-      })(),\n-\n-      isLastStep: (() => {\n-        const state = get();\n-        return state.currentStepPosition === state.totalSteps;\n-      })(),\n-\n-      nextButtonLabel: (() => {\n-        const state = get();\n-        const currentStep = state.getCurrentStep();\n-        return currentStep?.nextLabel || 'Next';\n-      })(),\n-\n-      previousButtonLabel: (() => {\n-        const state = get();\n-        const currentStep = state.getCurrentStep();\n-        return currentStep?.previousLabel || 'Previous';\n-      })(),\n+        getPreviousStep: () => {\n+          const state = get();\n+          const currentStep = state.getCurrentStep();\n+          if (!currentStep) return undefined;\n+          return state.steps\n+            .filter((s) => s.order < currentStep.order)\n+            .sort((a, b) => b.order - a.order)[0];\n+        },\n+      };\n+    },\n     }),\n     {\n       name: 'wizard-store',\n     }\n"
                },
                {
                    "date": 1752380338874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -300,9 +300,8 @@\n             .sort((a, b) => b.order - a.order)[0];\n         },\n       };\n     },\n-    }),\n     {\n       name: 'wizard-store',\n     }\n   )\n"
                },
                {
                    "date": 1752383356446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,8 +31,9 @@\n   moveNext: () => Promise<void>;\n   moveBack: () => Promise<void>;\n   setStepData: (stepId: string, data: StepData) => Promise<void>;\n   updateField: (stepId: string, field: string, value: unknown) => Promise<void>;\n+  updateStepProperty: (stepId: string, property: keyof Step, value: unknown) => void;\n   reset: () => Promise<void>;\n   initializeSteps: (steps: Omit<Step, 'nextLabel' | 'previousLabel'>[], defaultNextLabel?: string, defaultPreviousLabel?: string, finishLabel?: string) => void;\n }\n \n"
                },
                {
                    "date": 1752383375086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,8 +188,21 @@\n           newStepData.set(stepId, newData);\n           set(updateStateWithDerived({ stepData: newStepData }), false, 'updateField');\n         },\n \n+        updateStepProperty: (stepId: string, property: keyof Step, value: unknown) => {\n+          const state = get();\n+          const stepIndex = state.steps.findIndex(s => s.id === stepId);\n+          if (stepIndex !== -1) {\n+            const updatedSteps = [...state.steps];\n+            updatedSteps[stepIndex] = {\n+              ...updatedSteps[stepIndex],\n+              [property]: value\n+            } as Step;\n+            set(updateStateWithDerived({ steps: updatedSteps }), false, 'updateStepProperty');\n+          }\n+        },\n+\n         reset: async () => {\n           const state = get();\n           const firstStep = [...state.steps]\n             .sort((a, b) => a.order - b.order)[0];\n"
                },
                {
                    "date": 1752383602797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -73,14 +73,15 @@\n   }\n };\n \n // Helper function to compute derived state\n-const computeDerivedState = (state: WizardState) => {\n-  const currentStep = state.steps.find((s) => s.order === state.currentStepPosition);\n+const computeDerivedState = (state: Partial<WizardState>, currentState?: WizardState) => {\n+  const fullState = { ...currentState, ...state } as WizardState;\n+  const currentStep = fullState.steps.find((s) => s.order === fullState.currentStepPosition);\n   return {\n     canMoveNext: currentStep ? currentStep.canMoveNext : false,\n-    isFirstStep: state.currentStepPosition === 1,\n-    isLastStep: state.currentStepPosition === state.totalSteps,\n+    isFirstStep: fullState.currentStepPosition === 1,\n+    isLastStep: fullState.currentStepPosition === fullState.totalSteps,\n     nextButtonLabel: currentStep?.nextLabel || 'Next',\n     previousButtonLabel: currentStep?.previousLabel || 'Previous',\n   };\n };\n"
                },
                {
                    "date": 1752383617488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,11 +91,10 @@\n   devtools(\n     (set, get) => {\n       const updateStateWithDerived = (newState: Partial<WizardState>) => {\n         const currentState = get();\n-        const updatedState = { ...currentState, ...newState };\n-        const derived = computeDerivedState(updatedState);\n-        return { ...updatedState, ...derived };\n+        const derived = computeDerivedState(newState, currentState);\n+        return { ...currentState, ...newState, ...derived };\n       };\n \n       return {\n         // Initial state\n"
                }
            ],
            "date": 1752380104034,
            "name": "Commit-0",
            "content": "import { create } from 'zustand';\nimport { devtools } from 'zustand/middleware';\n\n// Types for the Zustand store\nexport interface Step {\n  id: string;\n  order: number;\n  canMoveNext: boolean;\n  nextLabel: string;\n  previousLabel: string;\n}\n\nexport type StepData = Record<string, unknown>;\n\nexport interface WizardState {\n  // Core state properties (equivalent to MST model properties)\n  currentStepId: string;\n  currentStepPosition: number;\n  isLoading: boolean;\n  error: string;\n  stepData: Map<string, StepData>;\n  steps: Step[];\n  totalSteps: number;\n}\n\nexport interface WizardActions {\n  // Actions (equivalent to MST actions)\n  setLoading: (isLoading: boolean) => void;\n  setError: (error: string | null) => void;\n  setCurrentStep: (stepId: string) => Promise<void>;\n  moveNext: () => Promise<void>;\n  moveBack: () => Promise<void>;\n  setStepData: (stepId: string, data: StepData) => Promise<void>;\n  updateField: (stepId: string, field: string, value: unknown) => Promise<void>;\n  reset: () => Promise<void>;\n  initializeSteps: (steps: Omit<Step, 'nextLabel' | 'previousLabel'>[], defaultNextLabel?: string, defaultPreviousLabel?: string, finishLabel?: string) => void;\n}\n\nexport interface WizardSelectors {\n  // Computed values (equivalent to MST views)\n  getCurrentStep: () => Step | undefined;\n  getStepById: (id: string) => Step | undefined;\n  getStepData: (stepId: string) => StepData;\n  getWizardData: () => Record<string, StepData>;\n  getNextStep: () => Step | undefined;\n  getPreviousStep: () => Step | undefined;\n  canMoveNext: boolean;\n  isFirstStep: boolean;\n  isLastStep: boolean;\n  nextButtonLabel: string;\n  previousButtonLabel: string;\n}\n\nexport type WizardStore = WizardState & WizardActions & WizardSelectors;\n\n// Helper function to validate step ordering\nconst validateSteps = (steps: Step[]): void => {\n  if (steps.length === 0) {\n    throw new Error('Wizard must have at least one step');\n  }\n\n  const sortedSteps = [...steps].sort((a, b) => a.order - b.order);\n  \n  for (let i = 0; i < sortedSteps.length; i++) {\n    const step = sortedSteps[i];\n    if (!step || step.order !== i + 1) {\n      throw new Error(\n        `Step orders must be sequential starting from 1. Found order ${step?.order} at index ${i}`\n      );\n    }\n  }\n};\n\n// Create the Zustand store\nexport const useWizardStore = create<WizardStore>()(\n  devtools(\n    (set, get) => ({\n      // Initial state\n      currentStepId: '',\n      currentStepPosition: 0,\n      isLoading: false,\n      error: '',\n      stepData: new Map<string, StepData>(),\n      steps: [],\n      totalSteps: 0,\n\n      // Actions\n      setLoading: (isLoading: boolean) => {\n        set({ isLoading }, false, 'setLoading');\n      },\n\n      setError: (error: string | null) => {\n        set({ error: error || '' }, false, 'setError');\n      },\n\n      setCurrentStep: async (stepId: string) => {\n        const state = get();\n        const step = state.steps.find((s) => s.id === stepId);\n        if (!step) {\n          console.error(`Step with id ${stepId} not found`);\n          return;\n        }\n        set(\n          {\n            currentStepId: stepId,\n            currentStepPosition: step.order,\n          },\n          false,\n          'setCurrentStep'\n        );\n      },\n\n      moveNext: async () => {\n        const state = get();\n        const nextStep = state.getNextStep();\n        if (nextStep) {\n          set(\n            {\n              currentStepId: nextStep.id,\n              currentStepPosition: nextStep.order,\n            },\n            false,\n            'moveNext'\n          );\n        }\n      },\n\n      moveBack: async () => {\n        const state = get();\n        const previousStep = state.getPreviousStep();\n        if (previousStep) {\n          set(\n            {\n              currentStepId: previousStep.id,\n              currentStepPosition: previousStep.order,\n            },\n            false,\n            'moveBack'\n          );\n        }\n      },\n\n      setStepData: async (stepId: string, data: StepData) => {\n        const state = get();\n        const step = state.steps.find((s) => s.id === stepId);\n        if (!step) {\n          console.error(`Step with id ${stepId} not found`);\n          return;\n        }\n        const newStepData = new Map(state.stepData);\n        newStepData.set(stepId, data);\n        set({ stepData: newStepData }, false, 'setStepData');\n      },\n\n      updateField: async (stepId: string, field: string, value: unknown) => {\n        const state = get();\n        const existingData = state.stepData.get(stepId) || {};\n        const newData = { ...existingData, [field]: value };\n        const newStepData = new Map(state.stepData);\n        newStepData.set(stepId, newData);\n        set({ stepData: newStepData }, false, 'updateField');\n      },\n\n      reset: async () => {\n        const state = get();\n        const firstStep = [...state.steps]\n          .sort((a, b) => a.order - b.order)[0];\n        \n        if (firstStep) {\n          set(\n            {\n              currentStepId: firstStep.id,\n              currentStepPosition: firstStep.order,\n              stepData: new Map<string, StepData>(),\n              isLoading: false,\n              error: '',\n            },\n            false,\n            'reset'\n          );\n        } else {\n          set(\n            {\n              currentStepId: '',\n              currentStepPosition: 0,\n              stepData: new Map<string, StepData>(),\n              isLoading: false,\n              error: '',\n            },\n            false,\n            'reset'\n          );\n        }\n      },\n\n      initializeSteps: (\n        steps: Omit<Step, 'nextLabel' | 'previousLabel'>[],\n        defaultNextLabel = 'Next',\n        defaultPreviousLabel = 'Previous',\n        finishLabel = 'Finish'\n      ) => {\n        const lastStepOrder = Math.max(...steps.map((s) => s.order), 0);\n        \n        const processedSteps: Step[] = steps.map((step) => {\n          const isLast = step.order === lastStepOrder;\n          return {\n            ...step,\n            nextLabel: isLast ? finishLabel : defaultNextLabel,\n            previousLabel: defaultPreviousLabel,\n          };\n        });\n\n        validateSteps(processedSteps);\n\n        const sortedSteps = [...processedSteps].sort((a, b) => a.order - b.order);\n        const firstStep = sortedSteps[0];\n\n        set(\n          {\n            steps: processedSteps,\n            totalSteps: processedSteps.length,\n            currentStepId: firstStep?.id || '',\n            currentStepPosition: firstStep?.order || 0,\n          },\n          false,\n          'initializeSteps'\n        );\n      },\n\n      // Selectors (computed values)\n      getCurrentStep: () => {\n        const state = get();\n        return state.steps.find((s) => s.order === state.currentStepPosition);\n      },\n\n      getStepById: (id: string) => {\n        const state = get();\n        return state.steps.find((s) => s.id === id);\n      },\n\n      getStepData: (stepId: string) => {\n        const state = get();\n        return state.stepData.get(stepId) || {};\n      },\n\n      getWizardData: () => {\n        const state = get();\n        const wizardData: Record<string, StepData> = {};\n        state.steps.forEach((step) => {\n          const stepData = state.stepData.get(step.id);\n          if (stepData) {\n            wizardData[step.id] = stepData;\n          }\n        });\n        return wizardData;\n      },\n\n      getNextStep: () => {\n        const state = get();\n        const currentStep = state.getCurrentStep();\n        if (!currentStep) return undefined;\n        return state.steps\n          .filter((s) => s.order > currentStep.order)\n          .sort((a, b) => a.order - b.order)[0];\n      },\n\n      getPreviousStep: () => {\n        const state = get();\n        const currentStep = state.getCurrentStep();\n        if (!currentStep) return undefined;\n        return state.steps\n          .filter((s) => s.order < currentStep.order)\n          .sort((a, b) => b.order - a.order)[0];\n      },\n\n      // Computed properties as functions (Zustand doesn't support getters the same way)\n      canMoveNext: (() => {\n        const state = get();\n        const currentStep = state.getCurrentStep();\n        return currentStep ? currentStep.canMoveNext : false;\n      })(),\n\n      isFirstStep: (() => {\n        const state = get();\n        return state.currentStepPosition === 1;\n      })(),\n\n      isLastStep: (() => {\n        const state = get();\n        return state.currentStepPosition === state.totalSteps;\n      })(),\n\n      nextButtonLabel: (() => {\n        const state = get();\n        const currentStep = state.getCurrentStep();\n        return currentStep?.nextLabel || 'Next';\n      })(),\n\n      previousButtonLabel: (() => {\n        const state = get();\n        const currentStep = state.getCurrentStep();\n        return currentStep?.previousLabel || 'Previous';\n      })(),\n    }),\n    {\n      name: 'wizard-store',\n    }\n  )\n);\n\n// Export types for external use\nexport type { WizardStore as WizardStoreType };\n"
        }
    ]
}