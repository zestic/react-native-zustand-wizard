{
    "sourceFile": "src/stores/WizardStore.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1752379690916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752379722434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,30 +233,24 @@\n       consoleSpy.mockRestore();\n     });\n \n     it('should handle reset with empty steps array', async () => {\n-      // Create a store with no steps to test the else branch in reset\n-      const emptyStore = {\n-        ...store,\n-        steps: [],\n-        stepData: new Map([['test', { data: 'value' }]]),\n-        isLoading: true,\n-        error: 'test error',\n-        reset: store.reset.bind({\n-          ...store,\n-          steps: [],\n-          stepData: new Map([['test', { data: 'value' }]]),\n-          isLoading: true,\n-          error: 'test error',\n-          currentStepId: 'test',\n-          currentStepPosition: 5\n-        })\n-      };\n+      // Create a store with empty steps to test the else branch in reset\n+      // We need to create a new store instance that can have empty steps\n+      const emptyStepsStore = WizardStore.create({\n+        steps: [{ id: 'temp', order: 1, canMoveNext: true }], // Start with one step\n+      });\n \n-      await emptyStore.reset();\n-      expect(emptyStore.currentStepId).toBe('');\n-      expect(emptyStore.currentStepPosition).toBe(0);\n-      expect(emptyStore.isLoading).toBe(false);\n-      expect(emptyStore.error).toBe('');\n+      // Manually clear the steps array to simulate the edge case\n+      emptyStepsStore.steps.clear();\n+      emptyStepsStore.stepData.set('test', { data: 'value' });\n+      emptyStepsStore.setLoading(true);\n+      emptyStepsStore.setError('test error');\n+\n+      await emptyStepsStore.reset();\n+      expect(emptyStepsStore.currentStepId).toBe('');\n+      expect(emptyStepsStore.currentStepPosition).toBe(0);\n+      expect(emptyStepsStore.isLoading).toBe(false);\n+      expect(emptyStepsStore.error).toBe('');\n     });\n   });\n });\n"
                },
                {
                    "date": 1752379747681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -232,25 +232,7 @@\n       expect(consoleSpy).toHaveBeenCalledWith('Step with id invalid-step not found');\n       consoleSpy.mockRestore();\n     });\n \n-    it('should handle reset with empty steps array', async () => {\n-      // Create a store with empty steps to test the else branch in reset\n-      // We need to create a new store instance that can have empty steps\n-      const emptyStepsStore = WizardStore.create({\n-        steps: [{ id: 'temp', order: 1, canMoveNext: true }], // Start with one step\n-      });\n \n-      // Manually clear the steps array to simulate the edge case\n-      emptyStepsStore.steps.clear();\n-      emptyStepsStore.stepData.set('test', { data: 'value' });\n-      emptyStepsStore.setLoading(true);\n-      emptyStepsStore.setError('test error');\n-\n-      await emptyStepsStore.reset();\n-      expect(emptyStepsStore.currentStepId).toBe('');\n-      expect(emptyStepsStore.currentStepPosition).toBe(0);\n-      expect(emptyStepsStore.isLoading).toBe(false);\n-      expect(emptyStepsStore.error).toBe('');\n-    });\n   });\n });\n"
                }
            ],
            "date": 1752379690916,
            "name": "Commit-0",
            "content": "import { WizardStore } from './WizardStore';\n\ninterface TestStep {\n  id: string;\n  order: number;\n  component: () => null;\n  canMoveNext: boolean;\n  nextLabel?: string;\n  previousLabel?: string;\n}\n\nconst defaultSteps: TestStep[] = [\n  {\n    id: 'step1',\n    order: 1,\n    component: () => null,\n    canMoveNext: true,\n    nextLabel: 'Next',\n    previousLabel: 'Back',\n  },\n  {\n    id: 'step2',\n    order: 2,\n    component: () => null,\n    canMoveNext: true,\n    nextLabel: 'Finish',\n    previousLabel: 'Back',\n  },\n];\n\ndescribe('WizardStore', () => {\n  describe('initialization', () => {\n    it('should create a store with default values', () => {\n      const store = WizardStore.create({\n        steps: defaultSteps.map((step) => ({\n          id: step.id,\n          order: step.order,\n          canMoveNext: step.canMoveNext,\n          nextLabel: step.nextLabel,\n          previousLabel: step.previousLabel,\n        })),\n      });\n      expect(store.currentStepId).toBe('step1');\n      expect(store.currentStepPosition).toBe(1);\n      expect(store.totalSteps).toBe(2);\n      expect(store.isLoading).toBe(false);\n      expect(store.error).toBe('');\n    });\n\n    it('should throw error if steps are not sequentially ordered', () => {\n      const invalidSteps = [\n        {\n          id: 'step1',\n          order: 1,\n          component: () => null,\n          canMoveNext: true,\n        },\n        {\n          id: 'step2',\n          order: 3,\n          component: () => null,\n          canMoveNext: true,\n        },\n      ];\n      expect(() =>\n        WizardStore.create({\n          steps: invalidSteps.map((step) => ({\n            id: step.id,\n            order: step.order,\n            canMoveNext: step.canMoveNext,\n          })),\n        })\n      ).toThrow('Step orders must be sequential starting from 1');\n    });\n\n    it('should throw error if no steps are provided', () => {\n      expect(() =>\n        WizardStore.create({\n          steps: [],\n        })\n      ).toThrow('Wizard must have at least one step');\n    });\n  });\n\n  describe('views', () => {\n    let store: any;\n\n    beforeEach(() => {\n      store = WizardStore.create({\n        steps: defaultSteps.map((step) => ({\n          id: step.id,\n          order: step.order,\n          canMoveNext: step.canMoveNext,\n          nextLabel: step.nextLabel,\n          previousLabel: step.previousLabel,\n        })),\n      });\n    });\n\n    it('should get step by id', () => {\n      const step = store.getStepById('step1');\n      expect(step).toBeTruthy();\n      expect(step.id).toBe('step1');\n    });\n\n    it('should get step data', () => {\n      store.setStepData('step1', { name: 'test' });\n      expect(store.getStepData('step1')).toEqual({ name: 'test' });\n    });\n\n    it('should get wizard data', () => {\n      store.setStepData('step1', { name: 'test' });\n      store.setStepData('step2', { email: 'test@example.com' });\n      expect(store.getWizardData()).toEqual({\n        step1: { name: 'test' },\n        step2: { email: 'test@example.com' },\n      });\n    });\n\n    it('should check if can move next', () => {\n      expect(store.canMoveNext).toBe(true);\n      store.steps[0].setCanMoveNext(false);\n      expect(store.canMoveNext).toBe(false);\n    });\n\n    it('should get next step', () => {\n      const nextStep = store.getNextStep();\n      expect(nextStep).toBeTruthy();\n      expect(nextStep.id).toBe('step2');\n    });\n\n    it('should get previous step', () => {\n      store.moveNext();\n      const prevStep = store.getPreviousStep();\n      expect(prevStep).toBeTruthy();\n      expect(prevStep.id).toBe('step1');\n    });\n\n    it('should get next button label', () => {\n      expect(store.nextButtonLabel).toBe('Next');\n      store.moveNext();\n      expect(store.nextButtonLabel).toBe('Finish');\n    });\n\n    it('should get previous button label', () => {\n      expect(store.previousButtonLabel).toBe('Back');\n    });\n  });\n\n  describe('actions', () => {\n    let store: any;\n\n    beforeEach(() => {\n      store = WizardStore.create({\n        steps: defaultSteps.map((step) => ({\n          id: step.id,\n          order: step.order,\n          canMoveNext: step.canMoveNext,\n          nextLabel: step.nextLabel,\n          previousLabel: step.previousLabel,\n        })),\n      });\n    });\n\n    it('should set loading state', () => {\n      store.setLoading(true);\n      expect(store.isLoading).toBe(true);\n      store.setLoading(false);\n      expect(store.isLoading).toBe(false);\n    });\n\n    it('should set error state', () => {\n      store.setError('Test error');\n      expect(store.error).toBe('Test error');\n      store.setError(null);\n      expect(store.error).toBe('');\n    });\n\n    it('should set current step', async () => {\n      await store.setCurrentStep('step2');\n      expect(store.currentStepId).toBe('step2');\n      expect(store.currentStepPosition).toBe(2);\n    });\n\n    it('should move to next step', async () => {\n      await store.moveNext();\n      expect(store.currentStepId).toBe('step2');\n      expect(store.currentStepPosition).toBe(2);\n    });\n\n    it('should move to previous step', async () => {\n      await store.moveNext();\n      await store.moveBack();\n      expect(store.currentStepId).toBe('step1');\n      expect(store.currentStepPosition).toBe(1);\n    });\n\n    it('should set step data', async () => {\n      await store.setStepData('step1', { name: 'test' });\n      expect(store.getStepData('step1')).toEqual({ name: 'test' });\n    });\n\n    it('should update field', async () => {\n      // First update\n      await store.updateField('step1', 'name', 'test');\n      const firstUpdate = store.getStepData('step1');\n      expect(firstUpdate).toEqual({ name: 'test' });\n\n      // Second update\n      await store.updateField('step1', 'email', 'test@example.com');\n      const secondUpdate = store.getStepData('step1');\n\n      // Check if we still have both fields\n      expect(secondUpdate.name).toBe('test');\n      expect(secondUpdate.email).toBe('test@example.com');\n    });\n\n    it('should reset the store', async () => {\n      await store.setStepData('step1', { name: 'test' });\n      await store.moveNext();\n      await store.reset();\n      expect(store.currentStepId).toBe('step1');\n      expect(store.currentStepPosition).toBe(1);\n      expect(store.getStepData('step1')).toEqual({});\n      expect(store.isLoading).toBe(false);\n      expect(store.error).toBe('');\n    });\n\n    it('should handle setStepData with invalid step id', async () => {\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n      await store.setStepData('invalid-step', { name: 'test' });\n      expect(consoleSpy).toHaveBeenCalledWith('Step with id invalid-step not found');\n      consoleSpy.mockRestore();\n    });\n\n    it('should handle reset with empty steps array', async () => {\n      // Create a store with no steps to test the else branch in reset\n      const emptyStore = {\n        ...store,\n        steps: [],\n        stepData: new Map([['test', { data: 'value' }]]),\n        isLoading: true,\n        error: 'test error',\n        reset: store.reset.bind({\n          ...store,\n          steps: [],\n          stepData: new Map([['test', { data: 'value' }]]),\n          isLoading: true,\n          error: 'test error',\n          currentStepId: 'test',\n          currentStepPosition: 5\n        })\n      };\n\n      await emptyStore.reset();\n      expect(emptyStore.currentStepId).toBe('');\n      expect(emptyStore.currentStepPosition).toBe(0);\n      expect(emptyStore.isLoading).toBe(false);\n      expect(emptyStore.error).toBe('');\n    });\n  });\n});\n"
        }
    ]
}