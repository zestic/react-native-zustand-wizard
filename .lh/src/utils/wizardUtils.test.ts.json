{
    "sourceFile": "src/utils/wizardUtils.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752381709281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752381709281,
            "name": "Commit-0",
            "content": "import {\n  setWizardUtilsStore,\n  updateField,\n  useStepContext,\n  resetStore,\n} from './wizardUtils';\nimport { WizardStore } from '../stores/WizardStore';\nimport { renderHook, act } from '@testing-library/react-native';\n\n// Mock the WizardStore with basic functionality\nconst mockWizardStore = {\n  updateField: jest.fn(),\n  getStepData: jest.fn().mockReturnValue({}),\n  getStepById: jest.fn().mockReturnValue({\n    setCanMoveNext: jest.fn(),\n  }),\n  getCurrentStep: jest.fn().mockReturnValue({\n    canMoveNext: true,\n    nextLabel: 'Next',\n    previousLabel: 'Back',\n  }),\n  currentStepPosition: 1,\n  totalSteps: 3,\n  getCanMoveNext: jest.fn().mockReturnValue(true),\n  moveNext: jest.fn(),\n  moveBack: jest.fn(),\n};\n\njest.mock('../stores/WizardStore', () => ({\n  WizardStore: {\n    create: jest.fn().mockImplementation(() => mockWizardStore),\n  },\n}));\n\ndescribe('wizardUtils Base Tests', () => {\n  let mockStore: any;\n  let consoleWarnSpy: jest.SpyInstance;\n  let consoleErrorSpy: jest.SpyInstance;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockStore = WizardStore.create({ steps: [] });\n    resetStore();\n  });\n\n  afterEach(() => {\n    resetStore();\n  });\n\n  describe('Store Initialization', () => {\n    it('should initialize store reference successfully', () => {\n      expect(() => setWizardUtilsStore(mockStore)).not.toThrow();\n    });\n\n    it('should throw when initializing with null store', () => {\n      expect(() => setWizardUtilsStore(null as any)).toThrow(\n        'Cannot initialize with null store'\n      );\n    });\n  });\n\n  describe('Field Updates', () => {\n    it('should update field in initialized store', () => {\n      setWizardUtilsStore(mockStore);\n      updateField('step1', 'field1', 'value1');\n      expect(mockStore.updateField).toHaveBeenCalledWith(\n        'step1',\n        'field1',\n        'value1'\n      );\n    });\n\n    it('should throw when updating field in uninitialized store', () => {\n      resetStore();\n      expect(() => updateField('step1', 'field1', 'value1')).toThrow(\n        'Store not initialized'\n      );\n    });\n  });\n\n  describe('Step Context Hook', () => {\n    const TEST_STEP_ID = 'test-step-1';\n\n    beforeEach(() => {\n      setWizardUtilsStore(mockStore);\n    });\n\n    it('should provide step context with correct interface', () => {\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n\n      expect(result.current).toEqual(\n        expect.objectContaining({\n          stepId: TEST_STEP_ID,\n          updateField: expect.any(Function),\n          getStepData: expect.any(Function),\n          canMoveNext: expect.any(Function),\n        })\n      );\n    });\n\n    it('should handle field updates through context', () => {\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n\n      act(() => {\n        result.current.updateField('testField', 'testValue');\n      });\n\n      expect(mockStore.updateField).toHaveBeenCalledWith(\n        TEST_STEP_ID,\n        'testField',\n        'testValue'\n      );\n    });\n\n    it('should handle missing step gracefully', () => {\n      mockStore.getStepById.mockReturnValueOnce(undefined);\n      const { result } = renderHook(() => useStepContext('missing-step'));\n\n      expect(result.current.canMoveNext).toBeInstanceOf(Function);\n      expect(() => result.current.canMoveNext(true)).not.toThrow();\n    });\n\n    it('should handle step data retrieval', () => {\n      const testData = { field1: 'value1' };\n      mockStore.getStepData.mockReturnValue(testData);\n\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n      const data = result.current.getStepData();\n\n      expect(mockStore.getStepData).toHaveBeenCalledWith(TEST_STEP_ID);\n      expect(data).toEqual(testData);\n    });\n\n    it('should throw when store is not initialized', () => {\n      resetStore();\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n\n      expect(() => result.current.updateField('field1', 'value1')).toThrow(\n        'Store not initialized'\n      );\n      expect(() => result.current.getStepData()).toThrow(\n        'Store not initialized'\n      );\n      expect(() => result.current.canMoveNext(true)).toThrow(\n        'Store not initialized'\n      );\n    });\n\n    it('should update step canMoveNext state', () => {\n      const mockStep = { setCanMoveNext: jest.fn() };\n      mockStore.getStepById.mockReturnValue(mockStep);\n\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n\n      act(() => {\n        result.current.canMoveNext(true);\n      });\n\n      expect(mockStore.getStepById).toHaveBeenCalledWith(TEST_STEP_ID);\n      expect(mockStep.setCanMoveNext).toHaveBeenCalledWith(true);\n\n      act(() => {\n        result.current.canMoveNext(false);\n      });\n\n      expect(mockStep.setCanMoveNext).toHaveBeenCalledWith(false);\n    });\n  });\n});\n"
        }
    ]
}