{
    "sourceFile": "src/utils/wizardUtils.integration.test.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1752381687279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1752381687279,
            "name": "Commit-0",
            "content": "import {\n  setWizardUtilsStore,\n  useNavigationContext,\n  useStepContext,\n} from './wizardUtils';\nimport { renderHook, act } from '@testing-library/react-native';\n\ndescribe('wizardUtils Integration Tests', () => {\n  let consoleWarnSpy: jest.SpyInstance;\n  let consoleErrorSpy: jest.SpyInstance;\n  let store: any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  afterEach(() => {\n    try {\n      setWizardUtilsStore(null as any);\n    } catch (e) {\n      // Ignore error when resetting store\n    }\n  });\n\n  describe('Navigation Configuration', () => {\n    it('should handle single step wizard', () => {\n      // Setup store before initializing hook\n      store = {\n        currentStepPosition: 0,\n        totalSteps: 1,\n        getCurrentStep: jest.fn().mockReturnValue({\n          canMoveNext: false,\n          nextLabel: 'Finish',\n          previousLabel: 'Back',\n        }),\n        getNavigationConfig: jest.fn().mockReturnValue({\n          isPreviousHidden: true,\n          isNextDisabled: true,\n          nextLabel: 'Finish',\n          previousLabel: 'Back',\n          currentStepPosition: 0,\n          totalSteps: 1,\n          onNext: expect.any(Function),\n          onPrevious: expect.any(Function),\n        }),\n      };\n      setWizardUtilsStore(store);\n\n      const { result } = renderHook(() => useNavigationContext());\n\n      expect(result.current).toEqual({\n        isPreviousHidden: false,\n        isNextDisabled: false,\n        nextLabel: '',\n        previousLabel: '',\n        currentStepPosition: 0,\n        totalSteps: 1,\n        onNext: expect.any(Function),\n        onPrevious: expect.any(Function),\n      });\n    });\n\n    it('should handle middle step in multi-step wizard', () => {\n      // Setup store before initializing hook\n      store = {\n        currentStepPosition: 1,\n        totalSteps: 3,\n        getCurrentStep: jest.fn().mockReturnValue({\n          canMoveNext: true,\n          nextLabel: 'Continue',\n          previousLabel: 'Back',\n        }),\n        getNavigationConfig: jest.fn().mockReturnValue({\n          isPreviousHidden: false,\n          isNextDisabled: false,\n          nextLabel: 'Continue',\n          previousLabel: 'Back',\n          currentStepPosition: 1,\n          totalSteps: 3,\n          onNext: expect.any(Function),\n          onPrevious: expect.any(Function),\n        }),\n      };\n      setWizardUtilsStore(store);\n\n      const { result } = renderHook(() => useNavigationContext());\n\n      expect(result.current).toEqual({\n        isPreviousHidden: false,\n        isNextDisabled: false,\n        nextLabel: '',\n        previousLabel: '',\n        currentStepPosition: 1,\n        totalSteps: 3,\n        onNext: expect.any(Function),\n        onPrevious: expect.any(Function),\n      });\n    });\n  });\n\n  describe('Step Context', () => {\n    it('should update canMoveNext state on the step', () => {\n      const TEST_STEP_ID = 'test-step';\n      const mockStep = {\n        canMoveNext: false,\n        setCanMoveNext: jest.fn(function (this: any, value: boolean) {\n          this.canMoveNext = value;\n        }),\n      };\n      store = {\n        currentStepPosition: 1,\n        totalSteps: 2,\n        getCurrentStep: jest.fn().mockReturnValue(mockStep),\n        getStepById: jest.fn().mockReturnValue(mockStep),\n        getStepData: jest.fn().mockReturnValue({}),\n      };\n      setWizardUtilsStore(store);\n\n      // Initial state\n      const { result } = renderHook(() => useStepContext(TEST_STEP_ID));\n      expect(mockStep.canMoveNext).toBe(false);\n\n      // Update canMoveNext to true using the hook\n      act(() => {\n        result.current.canMoveNext(true);\n      });\n\n      // Step should now be updated\n      expect(mockStep.canMoveNext).toBe(true);\n      expect(mockStep.setCanMoveNext).toHaveBeenCalledWith(true);\n    });\n  });\n\n  describe('Navigation Actions', () => {\n    beforeEach(() => {\n      // Setup store with navigation actions\n      store = {\n        currentStepPosition: 1,\n        totalSteps: 3,\n        getCurrentStep: jest.fn().mockReturnValue({\n          canMoveNext: true,\n          nextLabel: 'Next',\n          previousLabel: 'Back',\n        }),\n        getNavigationConfig: jest.fn().mockReturnValue({\n          isPreviousHidden: false,\n          isNextDisabled: false,\n          nextLabel: 'Next',\n          previousLabel: 'Back',\n          currentStepPosition: 1,\n          totalSteps: 3,\n          onNext: async () => store.moveNext(),\n          onPrevious: async () => store.moveBack(),\n        }),\n        moveNext: jest.fn().mockResolvedValue(undefined),\n        moveBack: jest.fn().mockResolvedValue(undefined),\n      };\n      setWizardUtilsStore(store);\n    });\n\n    it('should handle next/previous navigation', async () => {\n      const { result } = renderHook(() => useNavigationContext());\n\n      await act(async () => {\n        await result.current.onNext();\n      });\n      expect(store.moveNext).toHaveBeenCalledTimes(1);\n\n      await act(async () => {\n        await result.current.onPrevious();\n      });\n      expect(store.moveBack).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n"
        }
    ]
}